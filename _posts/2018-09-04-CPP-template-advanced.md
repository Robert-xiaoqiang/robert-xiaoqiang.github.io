---
title: CPP-template-advanced
key: 201809040
tags: CPP template
---

# CPP-template-advanced

#### 成员模板
- 成员函数模板
   - 类成员 => 由函数模板参数确定函数实例
   - 模板成员 =>2套前缀 由类模板参数确定类实例, 函数模板参数确定函数实例
   > 1套前缀时, 类模板的成员一定是函数模板(即成员模板)
   > 

<!--more-->

#### 控制实例化, 显式实例化
> 解决的问题:
> 分离编译的文件使用模板时分别进行实例化
> 相同的模板实例存在于多个文件
> 

- 显式实例化定义
> 一句话, 要定死某个实例

```CPP
template class GT<args...>;     // 类模板
template float f(int a, int b); // 函数模板
```

- 显示实例化声明
> 一句话, extern声明
> 

```CPP
extern template class GT<args...>;  // 类模板
extern float f(int a, int b);       // 函数模板
```

- 注意
- `显示实例化定义后, 类模板的所有成员(成员模板)一定会都进行实例化, 而一般的模板实例化, 能保证有使用之处才进行成员实例化`

#### 函数模板类型转换
- 顶层`const`忽略 trival
- 允许`非const`初始化`const` trival
- 数组到元素指针左值, 函数到函数指针
- 数组绑定到数组引用无事, 绑定到元素引用GG+ERROR 注意

- 注意 `函数模板中的(不使用模板前缀的参数)应用正常的类型转换`
- `显式模板参数对应的位置`应用正常的类型转换
- 显式模板参数规则`从左向右, 最右侧可以省略, 应用编译器参数/类型推导`
- 参数推导过程, 即相同即相同, 不相同即不相同, 从左向右
> 某种程度上, 函数模板显式模板参数已经定死参数类型, 可以进行较为灵活的类型转换
> 

#### auto 类型指示符(type specifier)
- 定义一定要初始化, 类型推导
- 逗号连续声明, 初始化, 推导必须相同
- 以下为推导结果的详解
- 去引用 => trival
- 去顶层const => 保留底层const
- 加引用时, 即auto& 时会保留顶层const


#### decltype(exp) 类型指示符(type specifier)
- 推导后, 不求值, 可以不进行对象定义, 可以进行尾值返回类型声明
- 作用于单个变量/对象 => 完全类型+可选CV => 必要初始化动作
- 作用于表达式 => 表达式结果类型 => `r` `r + 0` `*p`
- 特例: `decltype((i))` => ()是优先级 => 特使EXP => 永远T&返回

