---
title: CPP-Exception-Advanced
key: 201809080
tags: CPP exception
---

# CPP-Exception-Advanced
> 已知
> 异常类/异常对象, CPP-runtime/编译器会维护一个副本copy
> 进入catch-handler时, 在try子句中, 编译器管理已构造局部对象(非指针), 进行析构
> 具体同如下DO
> 

<!--more-->

- 异常与构造函数
   - 抛出异常
      - 别人抛异常 => 我catch
      - 我基本不抛 => 否则, 擦屁股有哪些事 => DO
   - 捕获异常
      - 使用`函数try语句块, try位于冒号之前`, 将捕获的范围扩大到**构造函数初始值列表**(即**构造函数正确姿势**), 即初始化 => 对应被聚合对象的构造函数异常
      - `catch-handler/catch子句`做什么事情 => DO
   - DO
      - 已知, 即使不在`try`子句已经成功构造的`成员对象(非指针, 有成员)`,  CPP编译器会调用析构
      - 已知, 不会调用自己的析构
      - 问题是`指针维护的资源`比如`堆, 句柄, 着色器, DB`等依靠`拷贝控制成员`的东西, 且已经分配完成 => 资源泄露
      - 解决方式
         - 使用`smart pointer 对象`,  属于成员对象的析构
         - 此处, 必要时, 手动执行`析构应有的动作`
- 异常与析构函数
   - 抛出异常
      - 是UB, 任何析构该类对象时, 不捕获 => `std::terminate()`; 捕获 => 即自己吃自己的屎 => 有意义么
      - `try`子句中任何使用该类的局部对象, 编译器自动执行`如上已知`时, 进入任何一个`catch-handler/catch子句, 即发生`UB/terminate`, 否则无异常属于第一点情况
   - 捕获异常
      - 完全捕获所有异常, 且不要在`catch-handler`中继续抛出异常
      - 同时注意析构功能的完整性, 否则, 再次手动执行`析构应有的动作`
- `RAII`简述
   - 不需要`finally`关键字,  一个动作的执行, 使用`OO/OOP`, 使用`ctor/dtor`
   - 对于异常发生, `try`子句范围/成员对象范围, `CPP编译器`有自动析构
   - 将指针用于`smart-ptr<T>模板`才能解决所有问题啊!