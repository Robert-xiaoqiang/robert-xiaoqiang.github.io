---
title: JavaReview
key: 201812220
tags: Java
---

# 泛型

- 类方法泛型: 泛型参数必须为自己引入, 不能使用类引入的泛型参数

- 泛型类, 泛型方法的声明语法对比, 前者`Name<T extends/super>`, 后者`<T extends/super>`位于返回值之前, 参数/局部变量中的使用只能`T`
  - 显然, bounded只能用于泛型类, 泛型方法, 泛型句柄声明(此时只能WC), 不可作为真正参数(实参)

  - **这种问题引发的叫做: 泛型的使用, 泛型句柄的操作受限**
  - 记住此时是使用, 不是定义, 声明泛型, 此时要么完全定死类型, 要么WC
  - 而定义, 声明时, 是要么`T抽象`, 要么`WC抽象`

<!--more-->

- 泛型方法, 使用WC时, 不需要声明, 只能在已有的泛型类/接口中作为参数, 显然二者地位不对等

- super bounded的出现, 使得add/put/set对于倍bounded的类型为绝对合法

- 泛型参数`T`的数组`[]`, 可以做参数声明, 不可局部`new E[]{ }`  

  - **这种问题引发的叫做: 泛型参数的内部使用不可实例化, 只能引用, 操作**

- `GP[E]`的数组是不可以创建的, 除非`E == WC`, 原因思考之前总结, 哲学依据是, 显示转换, 优于隐式报错, 即**不允许确切类型的泛型数组**

  - 当然使用非泛型语法`new`, 交给泛型引用, 也可以

- `T, E`可以用于强制类型转换

- `bounded  类交集语法&`

- 类属性, 泛型GG

- 通过通配符, 可以在不同泛型参数之间转来转去

- instanceof 右操作数不能有具体的泛型参数

- `throws 可T, GP<T>`, `catch不可T, 不可GP<T>`

- 定义泛型异常(Throwable单根)类GG

- 泛型枚举GG



# 异常 & IO

# Threads

# JDBC & Socket

# RTTI & Reflection

